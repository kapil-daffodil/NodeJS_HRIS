var ApplaneCallback = require("./ApplaneCallback.js");
var ObjectID = require("mongodb").ObjectID;
var QueryConstants = require("nodejsapi/Constants.js");
var AppUtil = require("apputil/util");

exports.isDotted = function isDotted(expression) {
    var dottedPattern = /\./;
    return (dottedPattern.test(expression));
}

exports.getUnique = function () {
    return new ObjectID();
}

exports.isTemp = function (id) {
    var dottedPattern = /.+(temp)$/;
    return (dottedPattern.test(id));
}


exports.iterateArray = function (array, callback, task) {
    if (array && array.length > 0) {
        var length = array.length;
        var index = -1;
        var arrayCallback = ApplaneCallback(callback, function () {
            index = index + 1;
            if (index == length) {
                callback();
            } else {
                task(array[index], arrayCallback);
            }
        });
        arrayCallback();
    } else {
        callback();
    }
}

exports.iterateArrayWithIndex = function (array, callback, task) {
    if (array && array.length > 0) {
        var length = array.length;
        var index = -1;
        var arrayCallback = ApplaneCallback(callback, function () {
            index = index + 1;
            if (index == length) {
                callback();
            } else {
                task(index, array[index], arrayCallback);
            }
        });
        arrayCallback();
    } else {
        callback();
    }
}

exports.capitalize = function (s) {
    return s[0].toUpperCase() + s.slice(1);
}

exports.parseDateValue = function (colDef, value) {
    if (value == undefined || value == null || value.toString().trim() == 0) {
        return null;
    }
    if (value instanceof Date) {
        return value;
    }
    var format = colDef.format;
    if (!format) {
        format = "yyyy-mm-dd";
    }
    var requiredDate;
    if (format == "dd/mm/yyyy") {
        var parts = value.split("/");
        requiredDate = new Date(parseInt(parts[2], 10),
            parseInt(parts[1], 10) - 1,
            parseInt(parts[0], 10));
    } else {
        requiredDate = new Date(value);
    }
    return requiredDate;

}

exports.isEmailId = function (inputTxt) {
    var email = /^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/;
    return new RegExp(email).test(inputTxt)
}


exports.resolveDot = function (operations) {
    //collect dotted columns into one
    if (!operations) {
        return operations
    } else if (operations instanceof Array) {
        var operationCount = operations ? operations.length : 0;
        for (var i = 0; i < operationCount; i++) {
            operations[i] = this.resolveDot(operations[i]);
        }
        return operations
    } else if (operations instanceof ObjectID) {
        return operations;
    } else if (operations instanceof Date) {
        return operations;
    } else if (operations instanceof Object) {
        var newOperation = {};
        for (var exp in operations) {
            //check if exp is a dotted expression
            operations[exp] = this.resolveDot(operations[exp]);
            var dottedIndex = exp.indexOf(".");
            if (dottedIndex > 0) {
                var firstPart = exp.substring(0, dottedIndex);
                var secondPart = exp.substring(dottedIndex + 1);
                var firstPartValue = newOperation[firstPart];
                if (!firstPartValue) {
                    //check if exists in old values
                    firstPartValue = operations[firstPart];
                }
                if (!firstPartValue) {
                    firstPartValue = {};
                } else if (!(firstPartValue instanceof Object)) {
                    var temp = {};
                    temp[QueryConstants.Query._ID] = firstPartValue;
                    firstPartValue = temp;

                }
                firstPartValue[secondPart] = operations[exp];

                newOperation[firstPart] = this.resolveDot(firstPartValue);
            } else {
                if (!newOperation[exp]) {
                    newOperation[exp] = operations[exp];
                }
            }
        }
        return newOperation;
    } else {
        return operations;
    }

}
exports.deepEqual = function (a, e, names){
    if(a==e){
        return true;
    }else if(!(a instanceof Object) || !(e instanceof Object) ){
        return false;
    }
    var dif = {};
    var aKeys = Object.keys(a);
    var eKeys = Object.keys(e);
    var cKeys = aKeys;
    var dKeys = eKeys;
    var c = a;
    var d = e;
    var names = {
        c: names ? names['a'] : 'Actual',
        d: names ? names['e'] : 'Expected'
    }

    if(eKeys.length > aKeys.length){
        cKeys = eKeys;
        dKeys = aKeys;
        c = e;
        d = a;
        names = {
            d: names ? names['a'] : 'Actual',
            c: names ? names['e'] : 'Expected'
        }
    }

    for(var i = 0, co = cKeys.length; i < co; i++){
        var key = cKeys[i];

        if(c[key]===null && d[key]===null){
            continue;
        }
        if(typeof c[key] !== typeof d[key]){
            return false;
            continue;
        }

        if(typeof c[key] === 'function'){
            if(c[key].toString() !== d[key].toString()){
                return false
            }
            continue;
        }
        if(typeof c[key] === 'object'){
            if(c[key].length !== undefined){ // array
                var temp = c[key].slice(0);
                temp = temp.filter(function(el){
                    return (d[key].indexOf(el) === -1);
                });
                var message = '';
                if(temp.length > 0){
                    message += names['c'] + ' excess ' + JSON.stringify(temp);
                }

                temp = d[key].slice(0);
                temp = temp.filter(function(el){
                    return (c[key].indexOf(el) === -1);
                });
                if(temp.length > 0){
                    message += ' and ' + names['d'] + ' excess ' + JSON.stringify(temp);
                }
                if(message !== ''){
                    return false;
                }
                continue;
            }
            var diff = AppUtil.deepEqual(c[key], d[key], {a:names['c'],e:names['d']});
            if(diff !== true && Object.keys(diff).length > 0){
                return false;
            }
            continue;
        }
        // Simple types left so
        if(c[key] !== d[key]){
            return false;
        }
    }
    return true;
}
